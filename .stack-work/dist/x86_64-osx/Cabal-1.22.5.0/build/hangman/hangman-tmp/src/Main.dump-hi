
==================== FINAL INTERFACE ====================
2016-06-20 23:08:09.161101 UTC

interface main@main:Main 7103
  interface hash: 760c18edcb0cf6776ddea23022c1fb6c
  ABI hash: f8c27e6f1d9f504d97b912903e007cb8
  export-list hash: b5178784342dc75581e4666cd3b78c47
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c4d9cf7c8d6a602207741a999e4d7820
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.allWords
  Main.alreadyTried
  Main.charInWord
  Main.fillInCharacter
  Main.freshHangman
  Main.gameLost
  Main.gameWon
  Main.gameWord
  Main.gameWords
  Main.handleTry
  Main.main
  Main.maxTries
  Main.maxWordLength
  Main.minWordLength
  Main.randomWord
  Main.renderPuzzleChar
  Main.runGame
  Main.Hangman{Main.Hangman Main.filledCharacters Main.triedCharacters Main.word}
  Main.WordList
module dependencies:
package dependencies: random-1.1@IQxsFMAJSrCF7cHNxD7bSI*
                      array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA base-4.8.2.0*
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Format.Parse
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.LocalTime.LocalTime
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
import  -/  random-1.1@IQxsFMAJSrCF7cHNxD7bSI:System.Random f846d7495aa22d6383669937e7654c9b
import  -/  base-4.8.2.0:Control.Monad 480c5067477275068c9b98be08410df9
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Unicode cdf84fc3abbaf34ba6b6645291cef991
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.Exit f5581af4ad998e898da01fdc74c2769b
import  -/  base-4.8.2.0:System.IO 0899686bfc1d9ef72dff3de85e99862a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
fc6f4e392384cb78abe179879b66bde8
  $fShowHangman :: GHC.Show.Show Main.Hangman
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Hangman
                  Main.$fShowHangman_$cshowsPrec
                  Main.$fShowHangman_$cshow
                  Main.$fShowHangman_$cshowList -}
fc6f4e392384cb78abe179879b66bde8
  $fShowHangman1 ::
    Main.Hangman -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ x :: Main.Hangman s :: GHC.Base.String[OneShot] ->
                 case x of ww { Main.Hangman ww1 ww2 ww3 ->
                 GHC.Base.++ @ GHC.Types.Char (Main.$w$cshow ww2 ww3) s }) -}
3dc2ecafeb911901335cd7ad0c66f83e
  $fShowHangman2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' ') -}
fc6f4e392384cb78abe179879b66bde8
  $fShowHangman_$cshow :: Main.Hangman -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Main.Hangman ->
                 case w of ww { Main.Hangman ww1 ww2 ww3 ->
                 Main.$w$cshow ww2 ww3 }) -}
fc6f4e392384cb78abe179879b66bde8
  $fShowHangman_$cshowList :: [Main.Hangman] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [Main.Hangman] s :: GHC.Base.String ->
                 GHC.Show.showList__ @ Main.Hangman Main.$fShowHangman1 ls s) -}
fc6f4e392384cb78abe179879b66bde8
  $fShowHangman_$cshowsPrec ::
    GHC.Types.Int -> Main.Hangman -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><S(LSL),1*U(A,1*U,U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int x :: Main.Hangman s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Main.$fShowHangman_$cshow x))
                   s) -}
e3a866d72073ffaf4bc354c8e728ae98
  $w$cshow ::
    [GHC.Base.Maybe GHC.Types.Char]
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [GHC.Base.Maybe GHC.Types.Char]
                   ww1 :: GHC.Base.String ->
                 let {
                   n :: [GHC.Types.Char]
                   = GHC.CString.unpackAppendCString#
                       "\n\
                       \Guessed so far: "#
                       ww1
                 } in
                 case GHC.Base.map
                        @ (GHC.Base.Maybe GHC.Types.Char)
                        @ GHC.Types.Char
                        Main.renderPuzzleChar
                        ww of wild {
                   [] -> n
                   : x xs
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.:
                           @ GHC.Types.Char
                           x
                           (Data.OldList.prependToAll
                              @ GHC.Types.Char
                              Main.$fShowHangman2
                              xs))
                        n }) -}
f9aee69b3f16b9fc3ee79ff3c134f262
  $wa ::
    GHC.Base.String
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,1*U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: GHC.Base.String
                   w :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char ww1 0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 10) of wild {
                   GHC.Types.False -> (# w, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (GHC.CString.unpackAppendCString#
                                "Game over! The word was: "#
                                (GHC.Base.map
                                   @ GHC.Types.Char
                                   @ GHC.Types.Char
                                   GHC.Unicode.toUpper
                                   ww))
                             GHC.Types.True
                             w of ds1 { (#,#) ipv ipv1 ->
                      System.Exit.exitSuccess1 @ () ipv } } }) -}
3ff8cc3c6953ca3595a13e9eb0033f86
  $wa1 ::
    GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,1*U><S,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: [GHC.Base.Maybe GHC.Types.Char]
                   ww2 :: GHC.Base.String
                   w :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case (Main.gameWon_go ww1)
                        `cast`
                      (Data.Monoid.NTCo:All[0]) of wild {
                   GHC.Types.False -> (# w, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (GHC.CString.unpackAppendCString#
                                "Congrats! You've guessed the word "#
                                (let {
                                   z :: [GHC.Types.Char]
                                   = GHC.CString.unpackAppendCString#
                                       " in "#
                                       (case GHC.List.$wlenAcc
                                               @ GHC.Types.Char
                                               ww2
                                               0 of ww3 { DEFAULT ->
                                        case GHC.Show.$wshowSignedInt
                                               0
                                               ww3
                                               (GHC.Types.[]
                                                  @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                        GHC.Base.++
                                          @ GHC.Types.Char
                                          (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                                          Main.gameWon2 } })
                                 } in
                                 letrec {
                                   go :: [GHC.Types.Char] -> [GHC.Types.Char]
                                     {- Arity: 1, Strictness: <S,1*U> -}
                                   = \ ds :: [GHC.Types.Char] ->
                                     case ds of wild1 {
                                       [] -> z
                                       : y ys
                                       -> GHC.Types.:
                                            @ GHC.Types.Char
                                            (GHC.Unicode.toUpper y)
                                            (go ys) }
                                 } in
                                 go ww))
                             GHC.Types.True
                             w of ds1 { (#,#) ipv ipv1 ->
                      System.Exit.exitSuccess1 @ () ipv } }) -}
e6890414163b7660320b56dfb10af74a
  $wa2 ::
    GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,U><S,U><L,U><L,U>, Inline: [0] -}
eee45a1c120cf0e98e8783555ee1af83
  $wfillInCharacter ::
    GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Types.Char
    -> (# GHC.Base.String,
          [GHC.Base.Maybe GHC.Types.Char],
          GHC.Base.String #)
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: [GHC.Base.Maybe GHC.Types.Char]
                   ww2 :: GHC.Base.String
                   w :: GHC.Types.Char ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        w
                        ww2 of wild {
                   GHC.Types.False
                   -> case GHC.List.elem
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             w
                             ww of wild1 {
                        GHC.Types.False
                        -> (# ww, ww1, GHC.Types.: @ GHC.Types.Char w ww2 #)
                        GHC.Types.True
                        -> (# ww,
                              letrec {
                                go :: [GHC.Types.Char]
                                      -> [GHC.Base.Maybe GHC.Types.Char]
                                      -> [GHC.Base.Maybe GHC.Types.Char]
                                  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                                = \ ds :: [GHC.Types.Char]
                                    _ys :: [GHC.Base.Maybe GHC.Types.Char] ->
                                  case ds of wild2 {
                                    [] -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Char)
                                    : ipv ipv1
                                    -> case _ys of wild3 {
                                         [] -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Char)
                                         : ipv2 ipv3
                                         -> GHC.Types.:
                                              @ (GHC.Base.Maybe GHC.Types.Char)
                                              (case ipv2 of wild4 {
                                                 GHC.Base.Nothing
                                                 -> case ipv of ww3 { GHC.Types.C# ww4 ->
                                                    case {__pkg_ccall base-4.8.2.0 u_towlower GHC.Prim.Int#
                                                                                              -> GHC.Prim.State#
                                                                                                   GHC.Prim.RealWorld
                                                                                              -> (# GHC.Prim.State#
                                                                                                      GHC.Prim.RealWorld,
                                                                                                    GHC.Prim.Int# #)}
                                                           (GHC.Prim.ord# ww4)
                                                           GHC.Prim.realWorld# of wild5 { (#,#) ds1 ds2 ->
                                                    case GHC.Prim.tagToEnum#
                                                           @ GHC.Types.Bool
                                                           (GHC.Prim.leWord#
                                                              (GHC.Prim.int2Word# ds2)
                                                              __word 1114111) of wild6 {
                                                      GHC.Types.False
                                                      -> case GHC.Char.chr2 ds2
                                                         ret_ty (GHC.Base.Maybe GHC.Types.Char)
                                                         of {}
                                                      GHC.Types.True
                                                      -> case w of wild7 { GHC.Types.C# c2 ->
                                                         case GHC.Prim.tagToEnum#
                                                                @ GHC.Types.Bool
                                                                (GHC.Prim.eqChar#
                                                                   (GHC.Prim.chr# ds2)
                                                                   c2) of wild8 {
                                                           GHC.Types.False
                                                           -> GHC.Base.Nothing @ GHC.Types.Char
                                                           GHC.Types.True
                                                           -> GHC.Base.Just
                                                                @ GHC.Types.Char
                                                                ww3 } } } } }
                                                 GHC.Base.Just ipv4 -> wild4 })
                                              (go ipv1 ipv3) } }
                              } in
                              go ww ww1,
                              GHC.Types.: @ GHC.Types.Char w ww2 #) }
                   GHC.Types.True -> (# ww, ww1, ww2 #) }) -}
30eee0965e56f47b3cc1102ded03cafb
  $wxs :: GHC.Prim.Int# -> [GHC.Base.Maybe GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
fc6f4e392384cb78abe179879b66bde8
  data Hangman
    = Hangman {word :: GHC.Base.String,
               filledCharacters :: [GHC.Base.Maybe GHC.Types.Char],
               triedCharacters :: GHC.Base.String}
6f73c11f8ce4731fe58f7571b46c7c5e
  type WordList = [GHC.Base.String]
8e5f53b9bdbb5922dc73c9c9c216d858
  allWords :: GHC.Types.IO Main.WordList
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.allWords1
                  `cast`
                (Sym (GHC.Types.NTCo:IO[0] <Main.WordList>_R)) -}
eb1aa67134bbb8c5ca2962e350d63e8d
  allWords1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.WordList #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.allWords2
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2, Data.OldList.lines ipv3 #) } }) -}
8ee2bd7607e7040598a3386a25a9646b
  allWords2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "data/dict.txt"#) -}
cf8fb7533764945ac0c1957f2adaba06
  alreadyTried :: Main.Hangman -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ hangman :: Main.Hangman userTry :: GHC.Types.Char ->
                 case hangman of wild { Main.Hangman ds ds1 ds2 ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   userTry
                   ds2 }) -}
a49fa87c06e54ac513968f6158b93f66
  charInWord :: Main.Hangman -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ hangman :: Main.Hangman userTry :: GHC.Types.Char ->
                 case hangman of wild { Main.Hangman ds ds1 ds2 ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   userTry
                   ds }) -}
0a6b55bde24135ac8d969b3fc7fa0354
  fillInCharacter :: Main.Hangman -> GHC.Types.Char -> Main.Hangman
  {- Arity: 2, Strictness: <S(LLS),1*U(U,U,U)><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.Hangman w1 :: GHC.Types.Char ->
                 case w of ww { Main.Hangman ww1 ww2 ww3 ->
                 case Main.$wfillInCharacter
                        ww1
                        ww2
                        ww3
                        w1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 Main.Hangman ww5 ww6 ww7 } }) -}
93820b98a29d55e0aaa2c749f27186f8
  filledCharacters :: Main.Hangman -> [GHC.Base.Maybe GHC.Types.Char]
  RecSel Main.Hangman
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Hangman ->
                 case ds of wild { Main.Hangman ds1 ds2 ds3 -> ds2 }) -}
ec042cbb54bce7396791198a498b9be0
  freshHangman :: GHC.Base.String -> Main.Hangman
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 Main.Hangman
                   w
                   (case GHC.List.$wlenAcc @ GHC.Types.Char w 0 of ww2 { DEFAULT ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<# 0 ww2) of wild {
                      GHC.Types.False -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Char)
                      GHC.Types.True -> Main.$wxs ww2 } })
                   (GHC.Types.[] @ GHC.Types.Char)) -}
56b7225912b3327a4771b42c759a6e20
  gameLost :: Main.Hangman -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LLS),1*U(1*U,A,1*U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.gameLost1
                  `cast`
                (<Main.Hangman>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
6ae5fc8f759bba3929b1015d63d269bc
  gameLost1 ::
    Main.Hangman
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LLS),1*U(1*U,A,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.Hangman
                   w1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case w of ww { Main.Hangman ww1 ww2 ww3 ->
                 Main.$wa ww1 ww3 w1 }) -}
fda92424f4bc53fb45be21acc2f528eb
  gameWon :: Main.Hangman -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LSL),1*U(1*U,1*U,1*U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.gameWon1
                  `cast`
                (<Main.Hangman>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
e106cb0e925fd97c60e370d27e411107
  gameWon1 ::
    Main.Hangman
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LSL),1*U(1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.Hangman
                   w1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case w of ww { Main.Hangman ww1 ww2 ww3 ->
                 Main.$wa1 ww1 ww2 ww3 w1 }) -}
3d48503f7f56997c30f79c5671a3c820
  gameWon2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " tries."#) -}
e73b70146cef249aa4862299455b9625
  gameWon_go :: [GHC.Base.Maybe GHC.Types.Char] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6c4485a7441308ed38bb34e7ea407c53
  gameWord :: GHC.Types.IO GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.gameWord1
                  `cast`
                (Sym (GHC.Types.NTCo:IO[0] <GHC.Base.String>_R)) -}
666aa8e04b031d5e46646e2cfd921fb2
  gameWord1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Main.gameWord4 s of ds1 { (#,#) ipv ipv1 ->
                 Main.gameWord2 ipv1 ipv }) -}
e5eb51f69c0e411d5d87693a3317399b
  gameWord2 ::
    Main.WordList
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ wordList :: Main.WordList
                   s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case System.Random.$fRandomInt3
                        (Main.gameWord3,
                         case GHC.List.$wlenAcc
                                @ [GHC.Types.Char]
                                wordList
                                0 of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1) })
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.List.!! @ GHC.Base.String wordList ipv1 #) }) -}
494da07c7830d88f17d99f23214c3e12
  gameWord3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
db674816350371ad9498b20ec5c3d8f9
  gameWord4 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.WordList #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.allWords2
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.List.filter
                      @ [GHC.Types.Char]
                      Main.gameWord5
                      (Data.OldList.lines ipv3) #) } }) -}
8c28df36e2c3183c6c50cc3054cf532f
  gameWord5 :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ word1 :: [GHC.Types.Char] ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char word1 0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww2 9) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww2 5) } }) -}
51982cf3cfe51bb4d7f6ee6d39b365f9
  gameWords :: GHC.Types.IO Main.WordList
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.gameWord4
                  `cast`
                (Sym (GHC.Types.NTCo:IO[0] <Main.WordList>_R)) -}
0a169ffefd67c9ad4eca07df24a9d146
  handleTry ::
    Main.Hangman -> GHC.Types.Char -> GHC.Types.IO Main.Hangman
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.handleTry1
                  `cast`
                (<Main.Hangman>_R
                 ->_R <GHC.Types.Char>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Main.Hangman>_R)) -}
fa735393e5686be7386468931c038d5f
  handleTry1 ::
    Main.Hangman
    -> GHC.Types.Char
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.Hangman #)
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><L,U>,
     Unfolding: (\ hangman :: Main.Hangman
                   userTry :: GHC.Types.Char
                   s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Your guess was: "#
                           (GHC.Types.:
                              @ GHC.Types.Char
                              userTry
                              (GHC.Types.[] @ GHC.Types.Char)))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case hangman of wild { Main.Hangman ds ds2 ds3 ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        userTry
                        ds3 of wild1 {
                   GHC.Types.False
                   -> case GHC.List.elem
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             userTry
                             ds of wild2 {
                        GHC.Types.False
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  (GHC.Types.: @ GHC.Types.Char userTry Main.handleTry3)
                                  GHC.Types.True
                                  ipv of ds4 { (#,#) ipv2 ipv3 ->
                           (# ipv2,
                              case Main.$wfillInCharacter
                                     ds
                                     ds2
                                     ds3
                                     userTry of ww { (#,,#) ww1 ww2 ww3 ->
                              Main.Hangman ww1 ww2 ww3 } #) }
                        GHC.Types.True
                        -> (# ipv,
                              case Main.$wfillInCharacter
                                     ds
                                     ds2
                                     ds3
                                     userTry of ww { (#,,#) ww1 ww2 ww3 ->
                              Main.Hangman ww1 ww2 ww3 } #) }
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (GHC.Types.: @ GHC.Types.Char userTry Main.handleTry2)
                             GHC.Types.True
                             ipv of ds4 { (#,#) ipv2 ipv3 ->
                      (# ipv2,
                         case Main.$wfillInCharacter
                                ds
                                ds2
                                ds3
                                userTry of ww { (#,,#) ww1 ww2 ww3 ->
                         Main.Hangman ww1 ww2 ww3 } #) } } } }) -}
26b6176fbad7b49080887e663999a9bb
  handleTry2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " already guessed, try something else."#) -}
47be40ff01892d20791835445af0e543
  handleTry3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " is a miss! Try again."#) -}
ba797e56823b284fb1e497e201765087
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
f6d7d73435fb3401678253e8d9590f70
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.allWords2
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 let {
                   ipv4 :: Main.WordList
                   = GHC.List.filter
                       @ [GHC.Types.Char]
                       Main.gameWord5
                       (Data.OldList.lines ipv3)
                 } in
                 case System.Random.$fRandomInt3
                        (Main.gameWord3,
                         case GHC.List.$wlenAcc
                                @ [GHC.Types.Char]
                                ipv4
                                0 of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1) })
                        ipv2 of ds3 { (#,#) ipv5 ipv6 ->
                 let {
                   w :: GHC.Base.String
                   = case ipv6 of ww { GHC.Types.I# ww1 ->
                     GHC.List.$w!! @ GHC.Base.String ipv4 ww1 }
                 } in
                 case GHC.List.$wlenAcc @ GHC.Types.Char w 0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww2) of wild {
                   GHC.Types.False
                   -> Main.$wa2
                        w
                        (GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Char))
                        (GHC.Types.[] @ GHC.Types.Char)
                        ipv5
                   GHC.Types.True
                   -> Main.$wa2
                        w
                        (Main.$wxs ww2)
                        (GHC.Types.[] @ GHC.Types.Char)
                        ipv5 } } } } }) -}
4f37ad7008594fdfdf52b370c512b4cd
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
1614948bbeec970b3bf8a1ccc0586d12
  maxTries :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 10) -}
87c14380ec23834b29abe84e42515f47
  maxWordLength :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 9) -}
e7bac9ca2cd0871306be27d58a537ecd
  minWordLength :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 5) -}
9ab2b306d3f29644c7d85dec0bbfb28b
  randomWord :: Main.WordList -> GHC.Types.IO GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.gameWord2
                  `cast`
                (<Main.WordList>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Base.String>_R)) -}
89137f44d5209d928ad52718adf974da
  renderPuzzleChar :: GHC.Base.Maybe GHC.Types.Char -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: GHC.Base.Maybe GHC.Types.Char ->
                 case ds of wild {
                   GHC.Base.Nothing -> Main.renderPuzzleChar1
                   GHC.Base.Just character -> character }) -}
6eaa802aa7ca0ef789cbaaf29d850a9d
  renderPuzzleChar1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '_') -}
06d3b89663a3000881a291b9f1d03272
  runGame :: Main.Hangman -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LSL),U(U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.runGame1
                  `cast`
                (<Main.Hangman>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
3ab03b85d621e9e880f111364b444cab
  runGame1 ::
    Main.Hangman
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LSL),U(U,U,U)><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.Hangman
                   w1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case w of ww { Main.Hangman ww1 ww2 ww3 ->
                 Main.$wa2 ww1 ww2 ww3 w1 }) -}
286ddc95b1f8c42d1ce58e6b458c93ea
  triedCharacters :: Main.Hangman -> GHC.Base.String
  RecSel Main.Hangman
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Hangman ->
                 case ds of wild { Main.Hangman ds1 ds2 ds3 -> ds3 }) -}
98de84814b35b70e32e21fb9a2b08353
  word :: Main.Hangman -> GHC.Base.String
  RecSel Main.Hangman
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Hangman ->
                 case ds of wild { Main.Hangman ds1 ds2 ds3 -> ds1 }) -}
instance GHC.Show.Show [Main.Hangman] = Main.$fShowHangman
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

